// *Author: Daokun Hu
// *E-mail: Daokunhu@gmail.com

#define USE_PMEM

#include <errno.h>
#include <fcntl.h>
#include <libpmem.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <unistd.h>

#include <array>
#include <cassert>
#include <chrono>
#include <cinttypes>
#include <cmath>
#include <cstdint>
#include <cstdlib>
#include <cstring>
#include <fstream>
#include <iostream>
#include <map>
#include <queue>
#include <random>
#include <ratio>
#include <set>
#include <string>
#include <type_traits>

template <typename T>
struct is_duration : std::false_type {};

template <class Rep, std::intmax_t Num, std::intmax_t Denom>
struct is_duration<std::chrono::duration<Rep, std::ratio<Num, Denom>>>
    : std::true_type {};

/**
 * @brief Wrapper that implements stopwatch functionality.
 *
 */
class Timer {
 public:
  Timer() noexcept {}
  ~Timer() noexcept {}

  /**
   * @brief Start time counter.
   *
   */
  void start() noexcept { start_ = std::chrono::high_resolution_clock::now(); }

  /**
   * @brief Clear time counter.
   *
   */
  void clear() noexcept { start_ = {}; }

  /**
   * @brief Returns amount of elapsed time.
   *
   * @tparam T unit used to return.
   * @return float
   */
  template <typename T>
  float elapsed() noexcept {
    static_assert(is_duration<T>::value);

    auto stop = std::chrono::high_resolution_clock::now();
    std::chrono::duration<float, typename T::period> e = stop - start_;
    return e.count();
  }

  /**
   * @brief Returns true if given duration is elapsed since last call.
   *
   * @tparam T unit used by duration.
   * @param d duration to be checked.
   * @return true
   * @return false
   */
  template <typename T>
  bool is_elapsed(const T &d) noexcept {
    static_assert(is_duration<T>::value);

    static auto prev = start_;

    auto stop = std::chrono::high_resolution_clock::now();
    std::chrono::duration<float, typename T::period> e = stop - prev;

    if (e >= d) {
      prev = stop;
      return true;
    } else
      return false;
  }

 private:
  /// Time point when the stopwatched started.
  std::chrono::high_resolution_clock::time_point start_;
};

#ifdef USE_PMEM
/**
 * @brief Creat a PM pool by libpmem.
 * @note
 * @param  filename: the PM pool name
 * @param  size: the size of PM pool
 * @retval memory address of PM pool.
 */
void *creat_PM_pool(std::string poolname, size_t size) {
  void *ptr;
  size_t mapped_len;
  int is_pmem;
  if ((ptr = pmem_map_file(poolname.c_str(), size, PMEM_FILE_CREATE, 0666,
                           &mapped_len, &is_pmem)) == NULL) {
    perror("pmem_map_file");
    exit(0);
  }
  return ptr;
}
#endif

/**
 * @brief To generate random uniform integer
 * @note
 * @retval None
 */
class uniform_generator_t {
 public:
  /**
   * @param  N: the range
   */
  uniform_generator_t(size_t N) : dist_(1, N) {}

  /**
   * @brief get an random integer
   * @retval an random integer
   */
  uint64_t next() { return dist_(generator_); }

 private:
  std::uniform_int_distribution<uint64_t> dist_;
  std::default_random_engine generator_;
};

/**
 * @brief an array stores static chars for variable-length string value.
 */
char VALUES[1024 * 1024];

enum OP_t { OP_INVALID, OP_INSERT, OP_READ, OP_DELETE, OP_UPDATE };

/**
 * @brief a key-value pair
 */
struct item_t {
  OP_t op;
  size_t key;
  size_t value_len;
};

/**
 * @brief load workload generated by YCSB.
 */
class Read_YCSB {
 public:
  Read_YCSB(std::string data_path) {
    infile_load = std::ifstream(data_path);
    operate = std::map<std::string, OP_t>{
        {"INSERT", OP_INSERT},
        {"REMOVE", OP_DELETE},
        {"READ", OP_READ},
        {"UPDATE", OP_UPDATE},
    };
  }

  /**
   * @brief get all items at once, it may need large capacity of memory.
   * @retval all items with operations.
   */
  std::vector<item_t> read_all() {
    std::vector<item_t> kvs;
    while (infile_load.good()) {
      infile_load >> op >> key;
      if (operate[op] == OP_INSERT || operate[op] == OP_UPDATE) {
        infile_load >> value_len;
        kvs.push_back(
            item_t{.op = operate[op], .key = key, .value_len = value_len});
      } else if (operate[op] == OP_READ || operate[op] == OP_DELETE) {
        kvs.push_back(item_t{.op = operate[op], .key = key, .value_len = 0});
      } else {
        continue;
      }
    }
    return kvs;
  }
  /**
   * @brief  get an item at once
   * @retval an item, if there is no item left in data file, an item with
   * operation of OP_INVALID is returned.
   */
  item_t read_next() {
    while (infile_load.good()) {
      infile_load >> op >> key;
      if (operate[op] == OP_INSERT || operate[op] == OP_UPDATE) {
        infile_load >> value_len;
        return item_t{.op = operate[op], .key = key, .value_len = value_len};
      } else if (operate[op] == OP_READ || operate[op] == OP_DELETE) {
        return item_t{.op = operate[op], .key = key, .value_len = 0};
      } else {
        continue;
      }
    }
    return item_t{.op = OP_INVALID};
  }

 private:
  std::ifstream infile_load;
  std::map<std::string, OP_t> operate;
  std::string op;
  size_t key;
  size_t value_len;
};
class spinlock {
 private:
  std::atomic<bool> lock_ = {0};

 public:
  void lock() noexcept {
    for (;;) {
      // Optimistically assume the lock is free on the first try
      if (!lock_.exchange(true, std::memory_order_acquire)) {
        return;
      }
      // Wait for lock to be released without generating cache misses
      while (lock_.load(std::memory_order_relaxed)) {
        // Issue X86 PAUSE or ARM YIELD instruction to reduce contention between
        // hyper-threads
        __builtin_ia32_pause();
      }
    }
  }

  bool try_lock() noexcept {
    // First do a relaxed load to check if lock is free in order to prevent
    // unnecessary cache misses if someone does while(!try_lock())
    return !lock_.load(std::memory_order_relaxed) &&
           !lock_.exchange(true, std::memory_order_acquire);
  }

  void unlock() noexcept { lock_.store(false, std::memory_order_release); }
  auto load() noexcept { return lock_.load(); }
};